// Generated by CoffeeScript 1.6.3
(function() {
  var app, log, setupCircleDrawer, svg, svg2,
    __slice = [].slice;

  log = function() {
    var arg, args, _i, _len, _results;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    _results = [];
    for (_i = 0, _len = args.length; _i < _len; _i++) {
      arg = args[_i];
      _results.push(typeof console !== "undefined" && console !== null ? console.log(arg) : void 0);
    }
    return _results;
  };

  app = window.app = {};

  /*
  	begin
  */


  log("improved circle drawing");

  setupCircleDrawer = function(svg, defaultInteraction) {
    var background, backgroundCircle, cCenter, cGroup, circle, firstCircle, iMouse, lastMouse, middleCircle, mousedown, mousemove, mouseup, secondCircle, vector_length;
    if (defaultInteraction == null) {
      defaultInteraction = true;
    }
    background = svg.append('rect').attr('x', 0).attr('y', 0).attr('width', 450).attr('height', 450).style('fill', 'aliceblue');
    backgroundCircle = svg.append('circle').attr('cx', 225).attr('cy', 225).attr('r', 125);
    if (defaultInteraction) {
      backgroundCircle.style('fill', 'crimson');
    } else {
      backgroundCircle.style('fill', 'blue');
    }
    cGroup = svg.append('g');
    circle = cGroup.append('ellipse').attr('cx', 0).attr('cy', 0).attr('rx', 50).attr('ry', 50).style('stroke-dasharray', '5,5').style('stroke-width', '3').style('stroke', 'rgb(0,0,0)').style('fill', 'white').style('opacity', 0.8);
    firstCircle = cGroup.append('circle').attr('cx', -50).attr('cy', 0).attr('r', 3).style('fill', 'white');
    middleCircle = cGroup.append('circle').attr('cx', 0).attr('cy', 0).attr('r', 8).style('fill', 'white');
    secondCircle = cGroup.append('circle').attr('cx', 50).attr('cy', 0).attr('r', 3).style('fill', 'white');
    if (defaultInteraction) {
      iMouse = void 0;
      lastMouse = void 0;
      cCenter = [100, 100];
      vector_length = function(v) {
        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
      };
      mousedown = function() {
        d3.event.preventDefault();
        return iMouse = d3.mouse(this);
      };
      mousemove = function() {
        var cMouse, currentMouse, middle, r, v;
        d3.event.preventDefault();
        if (iMouse) {
          cMouse = d3.mouse(this);
          v = [cMouse[0] - iMouse[0], cMouse[1] - iMouse[1]];
          middle = [iMouse[0] + v[0] * 0.5, iMouse[1] + v[1] * 0.5];
          r = vector_length(v) / 2;
          cGroup.attr('transform', "translate(" + middle[0] + ", " + middle[1] + ")");
          circle.attr('rx', r).attr('ry', r);
          firstCircle.attr('cx', iMouse[0] - middle[0]).attr('cy', iMouse[1] - middle[1]);
          secondCircle.attr('cx', cMouse[0] - middle[0]).attr('cy', cMouse[1] - middle[1]);
          cCenter = middle;
        }
        if (lastMouse) {
          currentMouse = d3.mouse(svg[0][0]);
          cCenter = currentMouse;
          cGroup.attr('transform', "translate(" + cCenter[0] + ", " + cCenter[1] + ")");
          return lastMouse = currentMouse;
        }
      };
      mouseup = function() {
        d3.event.preventDefault();
        iMouse = void 0;
        return lastMouse = void 0;
      };
      background.on('mousedown', mousedown).on('touchstart', mousedown);
      backgroundCircle.on('mousedown', mousedown).on('touchstart', mousedown);
      middleCircle.on('mousedown', function() {
        d3.event.preventDefault();
        return lastMouse = d3.mouse(this);
      }).on('touchstart', function() {
        d3.event.preventDefault();
        return lastMouse = d3.mouse(this);
      });
      return svg.on('mousemove', mousemove).on('mouseup', mouseup).on('touchmove', mousemove).on('touchend', mouseup);
    } else {
      iMouse = void 0;
      lastMouse = void 0;
      cCenter = [100, 100];
      vector_length = function(v) {
        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
      };
      mousedown = function() {
        d3.event.preventDefault();
        return iMouse = d3.mouse(this);
      };
      mousemove = function() {
        var cMouse, currentMouse, middle, r, v;
        d3.event.preventDefault();
        if (iMouse) {
          cMouse = d3.mouse(this);
          v = [cMouse[0] - iMouse[0], cMouse[1] - iMouse[1]];
          middle = [iMouse[0] + v[0] * 0.5, iMouse[1] + v[1] * 0.5];
          r = vector_length(v) / 2;
          cGroup.attr('transform', "translate(" + middle[0] + ", " + middle[1] + ")");
          circle.attr('rx', Math.abs(v[0] / 2)).attr('ry', Math.abs(v[1] / 2));
          firstCircle.attr('cx', iMouse[0] - middle[0]).attr('cy', iMouse[1] - middle[1]);
          secondCircle.attr('cx', cMouse[0] - middle[0]).attr('cy', cMouse[1] - middle[1]);
          cCenter = middle;
        }
        if (lastMouse) {
          currentMouse = d3.mouse(svg[0][0]);
          cCenter = currentMouse;
          cGroup.attr('transform', "translate(" + cCenter[0] + ", " + cCenter[1] + ")");
          return lastMouse = currentMouse;
        }
      };
      mouseup = function() {
        d3.event.preventDefault();
        iMouse = void 0;
        return lastMouse = void 0;
      };
      background.on('mousedown', mousedown).on('touchstart', mousedown);
      backgroundCircle.on('mousedown', mousedown).on('touchstart', mousedown);
      middleCircle.on('mousedown', function() {
        d3.event.preventDefault();
        return lastMouse = d3.mouse(this);
      }).on('touchstart', function() {
        d3.event.preventDefault();
        return lastMouse = d3.mouse(this);
      });
      return svg.on('mousemove', mousemove).on('mouseup', mouseup).on('touchmove', mousemove).on('touchend', mouseup);
    }
  };

  svg = d3.select('#cont1').append('svg').attr('width', 450).attr('height', 450);

  setupCircleDrawer(svg);

  svg2 = d3.select('#cont2').append('svg').attr('width', 450).attr('height', 450);

  setupCircleDrawer(svg2, false);

}).call(this);

/*
//@ sourceMappingURL=main.map
*/
